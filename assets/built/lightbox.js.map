{"version":3,"names":[],"mappings":"","sources":["lightbox.js"],"sourcesContent":["/**\n * Enhanced Lightbox Component for FrameGrid Ghost Theme\n * Implements advanced navigation with looping, keyboard shortcuts, and accessibility\n * WCAG 2.1 AA Compliant with comprehensive focus management and screen reader support\n */\n\n// Enhanced navigation with accessibility and focus trapping\nfunction enhanceLightboxNavigation() {\n  // Wait for Alpine.js to be available\n  document.addEventListener(\"alpine:init\", () => {\n    // Store reference to the original portfolioGrid component\n    const originalPortfolioGrid = Alpine._x_dataStack;\n\n    // Enhance the existing Alpine.js component\n    Alpine.data(\"portfolioGrid\", () => ({\n      lightboxOpen: false,\n      currentIndex: 0,\n      loading: false,\n      imageLoading: false,\n      imageError: false,\n      posts: [],\n      currentPost: null,\n      imageCache: new Map(),\n      screenReaderAnnouncement: \"\",\n      lastFocusedElement: null,\n      focusableElements: [],\n      currentFocusIndex: 0,\n      keyboardDebounceTimer: null,\n\n      init() {\n        // Initialize posts data from server-side rendered content\n        // This will be populated by the Handlebars template\n        this.posts = window.portfolioPosts || [];\n\n        // Preload first few images for better UX\n        this.preloadInitialImages();\n\n        // Add enhanced keyboard event listeners\n        this.setupKeyboardNavigation();\n\n        // Set up focus management\n        this.setupFocusManagement();\n      },\n\n      initMasonry() {\n        // Initialize masonry layout\n        this.$nextTick(() => {\n          this.updateMasonryLayout();\n        });\n      },\n\n      updateMasonryLayout() {\n        // CSS Grid handles the masonry layout automatically\n        // This method can be extended for more complex masonry logic\n      },\n\n      openLightbox(index) {\n        // Store the currently focused element for restoration later\n        this.lastFocusedElement = document.activeElement;\n\n        this.currentIndex = index;\n        this.currentPost = this.posts[index];\n        this.lightboxOpen = true;\n        this.imageLoading = true;\n        this.imageError = false;\n\n        // Add body class to prevent scrolling and hide background content\n        document.body.classList.add(\"lightbox-open\");\n        this.setBackgroundInert(true);\n\n        // Announce to screen readers\n        this.announceToScreenReader(\n          `Opening image viewer. Image ${index + 1} of ${this.posts.length}: ${\n            this.currentPost?.title || \"Portfolio image\"\n          }. Use arrow keys to navigate, Tab to move between controls, Escape to close.`\n        );\n\n        // Focus management for accessibility\n        this.$nextTick(() => {\n          this.setupFocusTrap();\n          const closeButton = this.$refs.closeButton;\n          if (closeButton) {\n            closeButton.focus();\n            this.announceToScreenReader(\n              `Image viewer opened. Currently viewing ${\n                this.currentPost?.title || `image ${index + 1}`\n              }. ${index + 1} of ${this.posts.length} images.`\n            );\n          }\n        });\n\n        // Preload adjacent images for smooth navigation\n        this.preloadAdjacentImages(index);\n      },\n\n      closeLightbox() {\n        this.lightboxOpen = false;\n        this.imageLoading = false;\n        this.imageError = false;\n        this.screenReaderAnnouncement = \"\";\n        document.body.classList.remove(\"lightbox-open\");\n\n        // Restore background content\n        this.setBackgroundInert(false);\n\n        // Announce closure to screen readers\n        this.announceToScreenReader(\n          \"Image viewer closed. Returned to gallery.\"\n        );\n\n        // Restore focus to the previously focused element\n        this.$nextTick(() => {\n          if (\n            this.lastFocusedElement &&\n            typeof this.lastFocusedElement.focus === \"function\"\n          ) {\n            this.lastFocusedElement.focus();\n            this.announceToScreenReader(\n              `Returned focus to ${\n                this.lastFocusedElement.getAttribute(\"aria-label\") ||\n                \"gallery item\"\n              }.`\n            );\n          }\n          this.lastFocusedElement = null;\n        });\n      },\n\n      // Enhanced navigation methods with accessibility announcements\n      navigateToImage(direction) {\n        if (this.imageLoading || this.posts.length === 0) return;\n\n        let newIndex;\n        let announcement = \"\";\n\n        switch (direction) {\n          case \"next\":\n            newIndex =\n              this.currentIndex >= this.posts.length - 1\n                ? 0\n                : this.currentIndex + 1;\n            announcement =\n              newIndex === 0\n                ? \"Reached end of gallery, showing first image\"\n                : \"Next image\";\n            break;\n          case \"previous\":\n            newIndex =\n              this.currentIndex <= 0\n                ? this.posts.length - 1\n                : this.currentIndex - 1;\n            announcement =\n              newIndex === this.posts.length - 1\n                ? \"Reached beginning of gallery, showing last image\"\n                : \"Previous image\";\n            break;\n          case \"first\":\n            newIndex = 0;\n            announcement = \"First image\";\n            break;\n          case \"last\":\n            newIndex = this.posts.length - 1;\n            announcement = \"Last image\";\n            break;\n          default:\n            return;\n        }\n\n        this.currentIndex = newIndex;\n        this.currentPost = this.posts[newIndex];\n        this.imageLoading = true;\n        this.imageError = false;\n\n        // Comprehensive screen reader announcement\n        const fullAnnouncement = `${announcement}: ${\n          this.currentPost?.title || `Image ${newIndex + 1}`\n        }. ${newIndex + 1} of ${this.posts.length}. ${\n          this.currentPost?.excerpt\n            ? this.currentPost.excerpt.substring(0, 100)\n            : \"\"\n        }`;\n\n        this.announceToScreenReader(fullAnnouncement);\n\n        // Preload adjacent images with circular logic\n        this.preloadAdjacentImages(newIndex);\n      },\n\n      // Helper methods for ARIA labels\n      getPreviousImageIndex() {\n        return this.currentIndex <= 0\n          ? this.posts.length - 1\n          : this.currentIndex - 1;\n      },\n\n      getNextImageIndex() {\n        return this.currentIndex >= this.posts.length - 1\n          ? 0\n          : this.currentIndex + 1;\n      },\n\n      getPreviousImageTitle() {\n        const prevIndex = this.getPreviousImageIndex();\n        return this.posts[prevIndex]?.title || `Image ${prevIndex + 1}`;\n      },\n\n      getNextImageTitle() {\n        const nextIndex = this.getNextImageIndex();\n        return this.posts[nextIndex]?.title || `Image ${nextIndex + 1}`;\n      },\n\n      // Enhanced keyboard navigation handlers with debouncing\n      handleNavigationKey(direction, event) {\n        if (!this.lightboxOpen) return;\n        event.preventDefault();\n\n        // Clear existing timer\n        if (this.keyboardDebounceTimer) {\n          clearTimeout(this.keyboardDebounceTimer);\n        }\n\n        // Debounce rapid key presses\n        this.keyboardDebounceTimer = setTimeout(() => {\n          this.navigateToImage(direction);\n        }, 50);\n      },\n\n      handleEscapeKey(event) {\n        if (this.lightboxOpen) {\n          event.preventDefault();\n          this.closeLightbox();\n        }\n      },\n\n      handleTabKey(event) {\n        if (!this.lightboxOpen) return;\n        event.preventDefault();\n\n        this.updateFocusableElements();\n        if (this.focusableElements.length === 0) return;\n\n        this.currentFocusIndex =\n          (this.currentFocusIndex + 1) % this.focusableElements.length;\n        this.focusableElements[this.currentFocusIndex].focus();\n\n        // Announce what element is now focused\n        const focusedElement = this.focusableElements[this.currentFocusIndex];\n        const ariaLabel =\n          focusedElement.getAttribute(\"aria-label\") ||\n          focusedElement.textContent ||\n          focusedElement.tagName.toLowerCase();\n        this.announceToScreenReader(`Focused on ${ariaLabel}`);\n      },\n\n      handleShiftTabKey(event) {\n        if (!this.lightboxOpen) return;\n        event.preventDefault();\n\n        this.updateFocusableElements();\n        if (this.focusableElements.length === 0) return;\n\n        this.currentFocusIndex =\n          this.currentFocusIndex <= 0\n            ? this.focusableElements.length - 1\n            : this.currentFocusIndex - 1;\n        this.focusableElements[this.currentFocusIndex].focus();\n\n        // Announce what element is now focused\n        const focusedElement = this.focusableElements[this.currentFocusIndex];\n        const ariaLabel =\n          focusedElement.getAttribute(\"aria-label\") ||\n          focusedElement.textContent ||\n          focusedElement.tagName.toLowerCase();\n        this.announceToScreenReader(`Focused on ${ariaLabel}`);\n      },\n\n      setupFocusTrap() {\n        this.updateFocusableElements();\n        this.currentFocusIndex = 0;\n\n        // Set up proper ARIA attributes for focus trapping\n        const modal = this.$refs.lightboxModal;\n        if (modal) {\n          modal.setAttribute(\"data-focus-trapped\", \"true\");\n          modal.setAttribute(\"aria-hidden\", \"false\");\n        }\n      },\n\n      updateFocusableElements() {\n        const modal = this.$refs.lightboxModal;\n        if (!modal) return;\n\n        // Get all focusable elements within the lightbox\n        const focusableSelectors = [\n          \"button:not([disabled])\",\n          \"a[href]\",\n          '[tabindex=\"0\"]',\n          '[role=\"button\"]:not([aria-disabled=\"true\"])',\n        ].join(\", \");\n\n        this.focusableElements = Array.from(\n          modal.querySelectorAll(focusableSelectors)\n        ).filter((el) => {\n          // Only include visible elements\n          const style = window.getComputedStyle(el);\n          return (\n            (style.display !== \"none\" &&\n              style.visibility !== \"hidden\" &&\n              !el.hasAttribute(\"aria-hidden\")) ||\n            el.getAttribute(\"aria-hidden\") === \"false\"\n          );\n        });\n\n        // Update current focus index based on currently focused element\n        const currentlyFocused = document.activeElement;\n        const focusIndex = this.focusableElements.indexOf(currentlyFocused);\n        if (focusIndex >= 0) {\n          this.currentFocusIndex = focusIndex;\n        }\n      },\n\n      trapFocus() {\n        this.setupFocusTrap();\n      },\n\n      setupKeyboardNavigation() {\n        // Enhanced keyboard navigation with comprehensive accessibility\n        document.addEventListener(\n          \"keydown\",\n          (event) => {\n            if (!this.lightboxOpen) return;\n\n            switch (event.key) {\n              case \"ArrowLeft\":\n                event.preventDefault();\n                this.handleNavigationKey(\"previous\", event);\n                break;\n              case \"ArrowRight\":\n                event.preventDefault();\n                this.handleNavigationKey(\"next\", event);\n                break;\n              case \" \":\n                // Space bar navigation only if not focused on a button\n                if (!event.target.matches('button, [role=\"button\"], a')) {\n                  event.preventDefault();\n                  this.handleNavigationKey(\"next\", event);\n                }\n                break;\n              case \"Home\":\n                event.preventDefault();\n                this.handleNavigationKey(\"first\", event);\n                break;\n              case \"End\":\n                event.preventDefault();\n                this.handleNavigationKey(\"last\", event);\n                break;\n              case \"Escape\":\n                this.handleEscapeKey(event);\n                break;\n              case \"Tab\":\n                if (event.shiftKey) {\n                  this.handleShiftTabKey(event);\n                } else {\n                  this.handleTabKey(event);\n                }\n                break;\n              case \"Enter\":\n                // Handle Enter key on focused elements\n                if (\n                  event.target.matches(\n                    \".lightbox-nav, .lightbox-close, .error-retry-btn, .lightbox-tag\"\n                  )\n                ) {\n                  event.preventDefault();\n                  event.target.click();\n                }\n                break;\n            }\n          },\n          true\n        );\n      },\n\n      setupFocusManagement() {\n        // Set up focus event listeners for better accessibility\n        document.addEventListener(\"focusin\", (event) => {\n          if (!this.lightboxOpen) return;\n\n          // Ensure focus stays within the lightbox\n          const modal = this.$refs.lightboxModal;\n          if (modal && !modal.contains(event.target)) {\n            event.preventDefault();\n            this.updateFocusableElements();\n            if (this.focusableElements.length > 0) {\n              this.focusableElements[0].focus();\n            }\n          }\n        });\n      },\n\n      setBackgroundInert(inert) {\n        // Set background content as inert to prevent interaction\n        const mainContent = document.querySelector(\n          \"main, .site-main, body > div:not(.lightbox-modal)\"\n        );\n        if (mainContent) {\n          if (inert) {\n            mainContent.setAttribute(\"aria-hidden\", \"true\");\n            mainContent.setAttribute(\"inert\", \"\");\n            // Disable all interactive elements in background\n            const interactiveElements = mainContent.querySelectorAll(\n              \"button, a, input, select, textarea, [tabindex]\"\n            );\n            interactiveElements.forEach((el) => {\n              el.setAttribute(\"tabindex\", \"-1\");\n              el.classList.add(\"inert-background\");\n            });\n          } else {\n            mainContent.removeAttribute(\"aria-hidden\");\n            mainContent.removeAttribute(\"inert\");\n            // Re-enable interactive elements\n            const interactiveElements =\n              mainContent.querySelectorAll(\".inert-background\");\n            interactiveElements.forEach((el) => {\n              el.removeAttribute(\"tabindex\");\n              el.classList.remove(\"inert-background\");\n            });\n          }\n        }\n      },\n\n      handleImageLoad() {\n        this.imageLoading = false;\n        this.imageError = false;\n\n        // Announce successful image load\n        this.announceToScreenReader(\n          `Image loaded successfully. ${\n            this.currentPost?.title || `Image ${this.currentIndex + 1}`\n          }. ${\n            this.currentPost?.excerpt\n              ? this.currentPost.excerpt.substring(0, 80) + \"...\"\n              : \"\"\n          }`\n        );\n      },\n\n      handleImageError() {\n        this.imageLoading = false;\n        this.imageError = true;\n\n        // Announce image loading error\n        this.announceToScreenReader(\n          `Error loading image: ${\n            this.currentPost?.title || `Image ${this.currentIndex + 1}`\n          }. Please try again or use navigation to view other images.`\n        );\n      },\n\n      retryImageLoad() {\n        this.imageError = false;\n        this.imageLoading = true;\n\n        this.announceToScreenReader(\"Retrying image load...\");\n\n        // Force reload the image\n        const img = this.$refs.lightboxModal?.querySelector(\".lightbox-image\");\n        if (img) {\n          const src = img.src;\n          img.src = \"\";\n          setTimeout(() => {\n            img.src = src;\n          }, 100);\n        }\n      },\n\n      // Enhanced screen reader announcements with live regions\n      announceToScreenReader(message) {\n        if (!message) return;\n\n        // Clear previous announcement\n        this.screenReaderAnnouncement = \"\";\n\n        // Use a small delay to ensure screen readers pick up the change\n        setTimeout(() => {\n          this.screenReaderAnnouncement = message;\n\n          // Also update aria-live regions if they exist\n          const liveRegion = document.getElementById(\"lightbox-announcements\");\n          if (liveRegion) {\n            liveRegion.textContent = message;\n\n            // Clear the announcement after a delay to prepare for next one\n            setTimeout(() => {\n              liveRegion.textContent = \"\";\n            }, 1000);\n          }\n        }, 100);\n      },\n\n      getLightboxImageUrl(post) {\n        if (!post?.feature_image) return \"\";\n\n        // Use appropriate size based on screen size and pixel ratio\n        const isMobile = window.innerWidth <= 768;\n        const isHighDPI = window.devicePixelRatio > 1;\n\n        // Choose optimal size\n        let size = \"xl\"; // 2400px default\n        if (isMobile && !isHighDPI) {\n          size = \"l\"; // 1600px for mobile\n        } else if (isMobile && isHighDPI) {\n          size = \"xl\"; // 2400px for high-DPI mobile\n        }\n\n        // Ghost img_url helper equivalent for client-side\n        return this.getGhostImageUrl(post.feature_image, size);\n      },\n\n      getLightboxImageSrcset(post) {\n        if (!post?.feature_image) return \"\";\n\n        // Generate responsive srcset for optimal loading\n        const baseUrl = post.feature_image;\n        return [\n          `${this.getGhostImageUrl(baseUrl, \"l\")} 1600w`,\n          `${this.getGhostImageUrl(baseUrl, \"xl\")} 2400w`,\n        ].join(\", \");\n      },\n\n      getGhostImageUrl(imageUrl, size) {\n        if (!imageUrl) return \"\";\n\n        // Size mappings from package.json config\n        const sizes = {\n          xs: 300,\n          s: 600,\n          m: 1000,\n          l: 1600,\n          xl: 2400,\n        };\n\n        const width = sizes[size] || sizes[\"xl\"];\n\n        // Handle Ghost's image transformation URL pattern\n        if (imageUrl.includes(\"/content/images/\")) {\n          // For local Ghost installations\n          return imageUrl.replace(\n            \"/content/images/\",\n            `/content/images/size/w${width}/`\n          );\n        } else if (\n          imageUrl.includes(\"images.unsplash.com\") ||\n          imageUrl.includes(\"cdn.\")\n        ) {\n          // For external images, append size parameter\n          const separator = imageUrl.includes(\"?\") ? \"&\" : \"?\";\n          return `${imageUrl}${separator}w=${width}`;\n        }\n\n        // Fallback: return original URL\n        return imageUrl;\n      },\n\n      preloadInitialImages() {\n        // Preload first 3 images for better initial experience\n        const imagesToPreload = this.posts.slice(0, 3);\n        imagesToPreload.forEach((post) => {\n          if (post.feature_image) {\n            this.preloadImage(post);\n          }\n        });\n      },\n\n      preloadAdjacentImages(currentIndex) {\n        // Enhanced circular preloading - preload 2 images in each direction\n        const totalPosts = this.posts.length;\n        if (totalPosts <= 1) return;\n\n        const indicesToPreload = [];\n\n        // Calculate indices to preload (2 before, 2 after current)\n        for (let i = -2; i <= 2; i++) {\n          if (i === 0) continue; // Skip current image\n\n          let index = currentIndex + i;\n          // Handle circular logic\n          if (index < 0) {\n            index = totalPosts + index;\n          } else if (index >= totalPosts) {\n            index = index - totalPosts;\n          }\n\n          indicesToPreload.push(index);\n        }\n\n        // Preload calculated images\n        indicesToPreload.forEach((index) => {\n          const post = this.posts[index];\n          if (post?.feature_image) {\n            this.preloadImage(post);\n          }\n        });\n      },\n\n      preloadImage(post) {\n        const imageUrl = this.getLightboxImageUrl(post);\n        if (imageUrl && !this.imageCache.has(imageUrl)) {\n          const img = new Image();\n          img.onload = () => {\n            this.imageCache.set(imageUrl, true);\n          };\n          img.onerror = () => {\n            this.imageCache.set(imageUrl, false);\n          };\n          img.src = imageUrl;\n        }\n      },\n\n      async loadMore() {\n        if (this.loading) return;\n\n        this.loading = true;\n        this.announceToScreenReader(\"Loading more images...\");\n\n        try {\n          // Implement infinite scroll loading with Ghost Content API\n          const nextPage = \"{{pagination.next}}\";\n          if (nextPage) {\n            const response = await fetch(`${nextPage}?formats=html,json`);\n            const data = await response.json();\n\n            // Add new posts to the array and update the grid\n            if (data.posts) {\n              const newPosts = data.posts.map((post) => ({\n                id: post.id,\n                title: post.title,\n                excerpt: post.excerpt,\n                url: post.url,\n                feature_image: post.feature_image,\n                date: new Date(post.published_at).toLocaleDateString(\"en-US\", {\n                  year: \"numeric\",\n                  month: \"short\",\n                  day: \"numeric\",\n                }),\n                primary_tag: post.primary_tag?.name || \"\",\n              }));\n\n              this.posts.push(...newPosts);\n              this.announceToScreenReader(\n                `Loaded ${newPosts.length} more images. Total: ${this.posts.length} images.`\n              );\n\n              // Preload some of the new images\n              this.preloadNewImages(newPosts.slice(0, 2));\n            }\n          }\n        } catch (error) {\n          console.error(\"Error loading more posts:\", error);\n          this.announceToScreenReader(\n            \"Error loading more images. Please try again.\"\n          );\n        } finally {\n          this.loading = false;\n        }\n      },\n\n      preloadNewImages(newPosts) {\n        newPosts.forEach((post) => {\n          if (post.feature_image) {\n            this.preloadImage(post);\n          }\n        });\n      },\n    }));\n  });\n}\n\n// Initialize the enhanced lightbox navigation\nif (document.readyState === \"loading\") {\n  document.addEventListener(\"DOMContentLoaded\", enhanceLightboxNavigation);\n} else {\n  enhanceLightboxNavigation();\n}\n"],"file":"lightbox.js"}