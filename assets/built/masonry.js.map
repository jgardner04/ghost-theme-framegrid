{"version":3,"names":[],"mappings":"","sources":["masonry.js"],"sourcesContent":["/**\n * FrameGrid Ghost Theme - Masonry Layout Integration\n * Integrates Masonry.js with Alpine.js for responsive portfolio grid\n */\n\n/**\n * Alpine.js component for Masonry layout management\n */\ndocument.addEventListener(\"alpine:init\", () => {\n  Alpine.data(\"masonryGrid\", () => ({\n    // Component state\n    masonry: null,\n    isInitialized: false,\n    isLoading: true,\n    loadedImages: 0,\n    totalImages: 0,\n    resizeTimeout: null,\n\n    // Initialize the component\n    init() {\n      this.$nextTick(() => {\n        this.setupMasonry();\n      });\n    },\n\n    // Setup masonry layout\n    async setupMasonry() {\n      try {\n        // Wait for Masonry library to be available\n        if (typeof Masonry === \"undefined\") {\n          await this.loadMasonryLibrary();\n        }\n\n        // Count total images for loading progress\n        this.totalImages = this.$el.querySelectorAll(\"img\").length;\n\n        if (this.totalImages === 0) {\n          this.isLoading = false;\n          this.initializeMasonry();\n          return;\n        }\n\n        // Wait for images to load before initializing masonry\n        await this.waitForImages();\n        this.initializeMasonry();\n      } catch (error) {\n        console.error(\"Failed to setup masonry:\", error);\n        this.isLoading = false;\n        // Fallback to CSS Grid layout (already in place)\n      }\n    },\n\n    // Load Masonry library dynamically with improved error handling\n    loadMasonryLibrary() {\n      return new Promise((resolve, reject) => {\n        if (typeof Masonry !== \"undefined\") {\n          resolve();\n          return;\n        }\n\n        const script = document.createElement(\"script\");\n        script.src = \"/assets/built/vendor/masonry.pkgd.min.js\";\n        script.async = true;\n        script.crossOrigin = \"anonymous\";\n\n        script.onload = () => {\n          console.log(\"Masonry library loaded successfully\");\n          resolve();\n        };\n\n        script.onerror = () => {\n          console.error(\n            \"Failed to load Masonry library from CDN, trying fallback\"\n          );\n          // Fallback to CDN if local version fails\n          this.loadMasonryFromCDN().then(resolve).catch(reject);\n        };\n\n        document.head.appendChild(script);\n      });\n    },\n\n    // Fallback CDN loading for Masonry\n    loadMasonryFromCDN() {\n      return new Promise((resolve, reject) => {\n        const script = document.createElement(\"script\");\n        script.src =\n          \"https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js\";\n        script.async = true;\n        script.crossOrigin = \"anonymous\";\n\n        script.onload = () => {\n          console.log(\"Masonry library loaded from CDN fallback\");\n          resolve();\n        };\n\n        script.onerror = () => {\n          console.error(\"Failed to load Masonry library from all sources\");\n          reject(new Error(\"Failed to load Masonry library\"));\n        };\n\n        document.head.appendChild(script);\n      });\n    },\n\n    // Wait for all images to load\n    waitForImages() {\n      return new Promise((resolve) => {\n        const images = this.$el.querySelectorAll(\"img\");\n\n        if (images.length === 0) {\n          resolve();\n          return;\n        }\n\n        let loadedCount = 0;\n        const checkComplete = () => {\n          loadedCount++;\n          this.loadedImages = loadedCount;\n\n          if (loadedCount >= images.length) {\n            this.isLoading = false;\n            resolve();\n          }\n        };\n\n        images.forEach((img) => {\n          if (img.complete) {\n            checkComplete();\n          } else {\n            img.addEventListener(\"load\", checkComplete);\n            img.addEventListener(\"error\", checkComplete); // Count errors as \"loaded\" to prevent hanging\n          }\n        });\n      });\n    },\n\n    // Initialize Masonry instance with enhanced configuration\n    initializeMasonry() {\n      // Only initialize masonry on multi-column layouts\n      if (!this.shouldUseMasonry()) {\n        this.isInitialized = false;\n        return;\n      }\n\n      try {\n        // Enhanced Masonry configuration following best practices\n        this.masonry = new Masonry(this.$el, {\n          itemSelector: \".masonry-item\",\n          columnWidth: \".masonry-item\",\n          gutter: this.getGutterSize(),\n          percentPosition: true,\n          transitionDuration: \"0.3s\",\n          stagger: 30,\n          fitWidth: false,\n          originLeft: true,\n          originTop: true,\n          containerStyle: {\n            position: \"relative\",\n          },\n          stamp: \".stamp\", // Support for stamped elements\n        });\n\n        this.isInitialized = true;\n        this.setupResizeHandler();\n        this.setupIntersectionObserver();\n\n        // Trigger layout after initialization with slight delay\n        this.$nextTick(() => {\n          setTimeout(() => {\n            this.masonry.layout();\n            this.isLoading = false;\n          }, 100);\n        });\n\n        console.log(\n          \"Masonry initialized successfully with enhanced configuration\"\n        );\n      } catch (error) {\n        console.error(\"Failed to initialize masonry:\", error);\n        this.isInitialized = false;\n        this.isLoading = false;\n      }\n    },\n\n    // Setup Intersection Observer for lazy loading optimization\n    setupIntersectionObserver() {\n      if (\"IntersectionObserver\" in window && this.masonry) {\n        const options = {\n          root: null,\n          rootMargin: \"50px\",\n          threshold: 0.1,\n        };\n\n        this.intersectionObserver = new IntersectionObserver((entries) => {\n          entries.forEach((entry) => {\n            if (entry.isIntersecting) {\n              const item = entry.target;\n              // Trigger any lazy loading or animation effects\n              item.classList.add(\"masonry-item-visible\");\n\n              // Unobserve the item once it's visible\n              this.intersectionObserver.unobserve(item);\n            }\n          });\n        }, options);\n\n        // Observe all masonry items\n        const items = this.$el.querySelectorAll(\".masonry-item\");\n        items.forEach((item) => {\n          this.intersectionObserver.observe(item);\n        });\n      }\n    },\n\n    // Check if masonry should be used based on screen size\n    shouldUseMasonry() {\n      return window.innerWidth >= 768; // Only use masonry on tablet and desktop\n    },\n\n    // Get appropriate gutter size based on screen size\n    getGutterSize() {\n      if (window.innerWidth <= 640) {\n        return 6; // Mobile\n      } else if (window.innerWidth <= 768) {\n        return 8; // Tablet\n      }\n      return 10; // Desktop\n    },\n\n    // Setup responsive resize handler\n    setupResizeHandler() {\n      window.addEventListener(\"resize\", () => {\n        if (this.resizeTimeout) {\n          clearTimeout(this.resizeTimeout);\n        }\n\n        this.resizeTimeout = setTimeout(() => {\n          this.handleResize();\n        }, 250); // Debounce resize events\n      });\n    },\n\n    // Handle window resize\n    handleResize() {\n      const shouldUse = this.shouldUseMasonry();\n\n      if (shouldUse && !this.isInitialized) {\n        // Initialize masonry if we switched to multi-column\n        this.initializeMasonry();\n      } else if (!shouldUse && this.isInitialized) {\n        // Destroy masonry if we switched to single column\n        this.destroyMasonry();\n      } else if (this.isInitialized) {\n        // Update gutter size and relayout\n        this.masonry.options.gutter = this.getGutterSize();\n        this.masonry.layout();\n      }\n    },\n\n    // Add new items to masonry (for infinite scroll)\n    addItems(newItems) {\n      if (!this.isInitialized || !this.masonry) {\n        return;\n      }\n\n      try {\n        // Wait for new images to load\n        const images = newItems.querySelectorAll(\"img\");\n        let loadedCount = 0;\n\n        const checkComplete = () => {\n          loadedCount++;\n          if (loadedCount >= images.length) {\n            // Add items to masonry and layout\n            this.masonry.appended(newItems);\n            this.masonry.layout();\n          }\n        };\n\n        if (images.length === 0) {\n          this.masonry.appended(newItems);\n          this.masonry.layout();\n          return;\n        }\n\n        images.forEach((img) => {\n          if (img.complete) {\n            checkComplete();\n          } else {\n            img.addEventListener(\"load\", checkComplete);\n            img.addEventListener(\"error\", checkComplete);\n          }\n        });\n      } catch (error) {\n        console.error(\"Failed to add items to masonry:\", error);\n      }\n    },\n\n    // Relayout masonry (useful after content changes)\n    relayout() {\n      if (this.isInitialized && this.masonry) {\n        this.masonry.layout();\n      }\n    },\n\n    // Destroy masonry instance\n    destroyMasonry() {\n      if (this.masonry) {\n        this.masonry.destroy();\n        this.masonry = null;\n        this.isInitialized = false;\n      }\n    },\n\n    // Cleanup on component destroy\n    destroy() {\n      this.destroyMasonry();\n\n      if (this.resizeTimeout) {\n        clearTimeout(this.resizeTimeout);\n      }\n\n      // Clean up intersection observer\n      if (this.intersectionObserver) {\n        this.intersectionObserver.disconnect();\n        this.intersectionObserver = null;\n      }\n    },\n\n    // Get loading progress percentage\n    get loadingProgress() {\n      if (this.totalImages === 0) return 100;\n      return Math.round((this.loadedImages / this.totalImages) * 100);\n    },\n\n    // Check if loading is complete\n    get isLoadingComplete() {\n      return !this.isLoading && this.loadedImages >= this.totalImages;\n    },\n  }));\n});\n\n/**\n * Global masonry utilities\n */\nwindow.MasonryUtils = {\n  // Reinitialize all masonry grids on the page\n  reinitializeAll() {\n    const grids = document.querySelectorAll(\"[x-data*='masonryGrid']\");\n    grids.forEach((grid) => {\n      const component = Alpine.$data(grid);\n      if (component && typeof component.setupMasonry === \"function\") {\n        component.setupMasonry();\n      }\n    });\n  },\n\n  // Add items to a specific masonry grid\n  addItemsToGrid(gridElement, newItems) {\n    const component = Alpine.$data(gridElement);\n    if (component && typeof component.addItems === \"function\") {\n      component.addItems(newItems);\n    }\n  },\n\n  // Relayout all masonry grids\n  relayoutAll() {\n    const grids = document.querySelectorAll(\"[x-data*='masonryGrid']\");\n    grids.forEach((grid) => {\n      const component = Alpine.$data(grid);\n      if (component && typeof component.relayout === \"function\") {\n        component.relayout();\n      }\n    });\n  },\n};\n\n/**\n * Auto-initialize masonry on DOM ready for any existing grids\n */\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  // Small delay to ensure Alpine.js is fully initialized\n  setTimeout(() => {\n    window.MasonryUtils.reinitializeAll();\n  }, 100);\n});\n"],"file":"masonry.js"}