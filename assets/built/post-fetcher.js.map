{"version":3,"names":[],"mappings":"","sources":["post-fetcher.js"],"sourcesContent":["/**\n * Enhanced Post Fetching Service for Ghost\n * Handles API calls with filtering, sorting, pagination, and caching\n */\n\nclass PostFetcher {\n  constructor() {\n    this.cache = new Map();\n    this.cacheTimeout = 5 * 60 * 1000; // 5 minutes\n    this.retryAttempts = 3;\n    this.retryDelay = 1000; // 1 second\n  }\n\n  /**\n   * Fetch posts with advanced filtering and sorting\n   * @param {Object} options - Fetch options\n   * @param {string} options.category - Category filter (wildlife, landscape, etc.)\n   * @param {string} options.sort - Sort option (newest, oldest, alphabetical, etc.)\n   * @param {number} options.year - Year filter\n   * @param {boolean} options.featured - Featured posts only\n   * @param {number} options.page - Page number for pagination\n   * @param {number} options.limit - Posts per page\n   * @param {boolean} options.useCache - Whether to use cached results\n   * @returns {Promise<Object>} - Posts data with pagination info\n   */\n  async fetchPosts(options = {}) {\n    const {\n      category = null,\n      sort = \"newest\",\n      year = null,\n      featured = false,\n      page = 1,\n      limit = 12,\n      useCache = true,\n    } = options;\n\n    // Generate cache key\n    const cacheKey = this.generateCacheKey(options);\n\n    // Check cache first\n    if (useCache && this.cache.has(cacheKey)) {\n      const cached = this.cache.get(cacheKey);\n      if (Date.now() - cached.timestamp < this.cacheTimeout) {\n        return cached.data;\n      }\n      // Remove expired cache entry\n      this.cache.delete(cacheKey);\n    }\n\n    try {\n      // Build Ghost API URL\n      const apiUrl = this.buildApiUrl(options);\n\n      // Fetch with retry logic\n      const response = await this.fetchWithRetry(apiUrl);\n      const data = await response.json();\n\n      // Process and enhance the data\n      const processedData = this.processPostData(data, options);\n\n      // Cache the result\n      if (useCache) {\n        this.cache.set(cacheKey, {\n          data: processedData,\n          timestamp: Date.now(),\n        });\n      }\n\n      return processedData;\n    } catch (error) {\n      console.error(\"Error fetching posts:\", error);\n      throw new PostFetchError(\n        `Failed to fetch posts: ${error.message}`,\n        error\n      );\n    }\n  }\n\n  /**\n   * Build Ghost API URL with filters and parameters\n   * @private\n   */\n  buildApiUrl(options) {\n    const { category, sort, year, featured, page, limit } = options;\n\n    // Base API endpoint\n    let url = \"/ghost/api/v3/content/posts/\";\n    const params = new URLSearchParams();\n\n    // Build filter string\n    const filters = [\"tag:hash-portfolio\"];\n\n    if (category) {\n      filters.push(`tag:${category}`);\n    }\n\n    if (featured) {\n      filters.push(\"featured:true\");\n    }\n\n    if (year) {\n      filters.push(`published_at:>='${year}-01-01'`);\n      filters.push(`published_at:<'${parseInt(year) + 1}-01-01'`);\n    }\n\n    // Add filter parameter\n    if (filters.length > 0) {\n      params.set(\"filter\", filters.join(\"+\"));\n    }\n\n    // Add sorting\n    const sortOrder = this.getSortOrder(sort);\n    if (sortOrder) {\n      params.set(\"order\", sortOrder);\n    }\n\n    // Add pagination\n    params.set(\"page\", page.toString());\n    params.set(\"limit\", limit.toString());\n\n    // Include additional fields\n    params.set(\"include\", \"tags,authors\");\n    params.set(\n      \"fields\",\n      \"id,title,excerpt,feature_image,published_at,url,featured,primary_tag\"\n    );\n\n    return url + \"?\" + params.toString();\n  }\n\n  /**\n   * Convert sort option to Ghost API order parameter\n   * @private\n   */\n  getSortOrder(sort) {\n    const sortMap = {\n      newest: \"published_at desc\",\n      oldest: \"published_at asc\",\n      alphabetical: \"title asc\",\n      \"reverse-alphabetical\": \"title desc\",\n      featured: \"featured desc,published_at desc\",\n    };\n\n    return sortMap[sort] || sortMap[\"newest\"];\n  }\n\n  /**\n   * Process and enhance post data\n   * @private\n   */\n  processPostData(data, options) {\n    if (!data.posts) {\n      throw new Error(\"Invalid response format from Ghost API\");\n    }\n\n    // Enhance posts with additional computed properties\n    const enhancedPosts = data.posts.map((post) => ({\n      ...post,\n      // Add formatted date\n      formattedDate: this.formatDate(post.published_at),\n      // Add year for filtering\n      year: new Date(post.published_at).getFullYear(),\n      // Add optimized image URLs\n      optimizedImages: this.generateOptimizedImages(post.feature_image),\n      // Add category info\n      categoryInfo: this.extractCategoryInfo(post),\n    }));\n\n    return {\n      posts: enhancedPosts,\n      pagination: {\n        ...data.meta.pagination,\n        hasNext: data.meta.pagination.next !== null,\n        hasPrev: data.meta.pagination.prev !== null,\n        nextUrl: data.meta.pagination.next,\n        prevUrl: data.meta.pagination.prev,\n      },\n      totalCount: data.meta.pagination.total,\n      currentPage: data.meta.pagination.page,\n      totalPages: data.meta.pagination.pages,\n    };\n  }\n\n  /**\n   * Generate optimized image URLs for different screen sizes\n   * @private\n   */\n  generateOptimizedImages(featureImage) {\n    if (!featureImage) return null;\n\n    const sizes = {\n      thumb: 300,\n      small: 600,\n      medium: 1000,\n      large: 1600,\n      xlarge: 2400,\n    };\n\n    const optimized = {};\n\n    for (const [size, width] of Object.entries(sizes)) {\n      optimized[size] = this.getOptimizedImageUrl(featureImage, width);\n    }\n\n    // Generate srcset for responsive images\n    optimized.srcset = [\n      `${optimized.small} 600w`,\n      `${optimized.medium} 1000w`,\n      `${optimized.large} 1600w`,\n      `${optimized.xlarge} 2400w`,\n    ].join(\", \");\n\n    return optimized;\n  }\n\n  /**\n   * Get optimized image URL for specific width\n   * @private\n   */\n  getOptimizedImageUrl(imageUrl, width) {\n    if (!imageUrl) return \"\";\n\n    // Handle Ghost's image transformation\n    if (imageUrl.includes(\"/content/images/\")) {\n      return imageUrl.replace(\n        \"/content/images/\",\n        `/content/images/size/w${width}/`\n      );\n    }\n\n    // Handle external images\n    try {\n      const url = new URL(imageUrl);\n      if (url.hostname.includes(\"unsplash.com\")) {\n        url.searchParams.set(\"w\", width.toString());\n        url.searchParams.set(\"q\", \"80\");\n        return url.toString();\n      }\n    } catch (e) {\n      // Invalid URL, return original\n    }\n\n    return imageUrl;\n  }\n\n  /**\n   * Extract category information from post\n   * @private\n   */\n  extractCategoryInfo(post) {\n    const portfolioTags = [\"wildlife\", \"landscape\", \"underwater\", \"cityscape\"];\n    const categoryTag = post.tags?.find((tag) =>\n      portfolioTags.includes(tag.slug)\n    );\n\n    return {\n      category: categoryTag?.slug || \"other\",\n      categoryName: categoryTag?.name || \"Portfolio\",\n      categoryColor: this.getCategoryColor(categoryTag?.slug),\n    };\n  }\n\n  /**\n   * Get theme color for category\n   * @private\n   */\n  getCategoryColor(category) {\n    const colors = {\n      wildlife: \"green\",\n      landscape: \"blue\",\n      underwater: \"teal\",\n      cityscape: \"slate\",\n    };\n\n    return colors[category] || \"gray\";\n  }\n\n  /**\n   * Format date for display\n   * @private\n   */\n  formatDate(dateString) {\n    const date = new Date(dateString);\n    return date.toLocaleDateString(\"en-US\", {\n      year: \"numeric\",\n      month: \"short\",\n      day: \"numeric\",\n    });\n  }\n\n  /**\n   * Generate cache key from options\n   * @private\n   */\n  generateCacheKey(options) {\n    const keyParts = [\n      options.category || \"all\",\n      options.sort || \"newest\",\n      options.year || \"all\",\n      options.featured ? \"featured\" : \"all\",\n      options.page || 1,\n      options.limit || 12,\n    ];\n\n    return keyParts.join(\"-\");\n  }\n\n  /**\n   * Fetch with retry logic\n   * @private\n   */\n  async fetchWithRetry(url, attempt = 1) {\n    try {\n      const response = await fetch(url, {\n        headers: {\n          Accept: \"application/json\",\n          \"Cache-Control\": \"max-age=300\", // 5 minutes cache\n        },\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      return response;\n    } catch (error) {\n      if (attempt < this.retryAttempts) {\n        // Exponential backoff\n        const delay = this.retryDelay * Math.pow(2, attempt - 1);\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        return this.fetchWithRetry(url, attempt + 1);\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Preload next page for improved UX\n   */\n  async preloadNextPage(currentOptions) {\n    const nextPageOptions = {\n      ...currentOptions,\n      page: (currentOptions.page || 1) + 1,\n    };\n\n    try {\n      await this.fetchPosts(nextPageOptions);\n    } catch (error) {\n      // Silently handle preload errors\n      console.warn(\"Failed to preload next page:\", error);\n    }\n  }\n\n  /**\n   * Clear cache (useful for forced refresh)\n   */\n  clearCache() {\n    this.cache.clear();\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats() {\n    return {\n      size: this.cache.size,\n      keys: Array.from(this.cache.keys()),\n    };\n  }\n}\n\n/**\n * Custom error class for post fetching errors\n */\nclass PostFetchError extends Error {\n  constructor(message, originalError) {\n    super(message);\n    this.name = \"PostFetchError\";\n    this.originalError = originalError;\n  }\n}\n\n// Create global instance\nwindow.postFetcher = new PostFetcher();\n\n// Export for module systems\nif (typeof module !== \"undefined\" && module.exports) {\n  module.exports = { PostFetcher, PostFetchError };\n}\n"],"file":"post-fetcher.js"}